<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <meta name="author" content="Daniele Grattarola">
  <link rel="canonical" href="https://graphneural.network/data/">
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>Containers - Spektral</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../css/theme.css" />
  <link rel="stylesheet" href="../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
  <link href="../stylesheets/extra.css" rel="stylesheet" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "Containers";
    var mkdocs_page_input_path = "data.md";
    var mkdocs_page_url = "/data/";
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-125823175-1', 'auto');
      ga('send', 'pageview');
  </script>
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> Spektral</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="..">Home</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Tutorials</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../getting-started/">Getting started</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../data-modes/">Data modes</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../creating-dataset/">Creating a dataset</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../creating-layer/">Creating a layer</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../examples/">Examples</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Layers</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../layers/convolution/">Convolutional layers</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../layers/pooling/">Pooling layers</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../layers/base/">Base layers</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../models/">Models</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Data</span></p>
                <ul class="current">
                    <li class="toctree-l1 current"><a class="reference internal current" href="./">Containers</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#graph">Graph</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#dataset">Dataset</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#data-utils">Data utils</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#to_disjoint">to_disjoint</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#to_batch">to_batch</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#to_mixed">to_mixed</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#batch_generator">batch_generator</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#to_tf_signature">to_tf_signature</a>
    </li>
        </ul>
    </li>
    </ul>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../datasets/">Datasets</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../loaders/">Loaders</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../transforms/">Transforms</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Utils</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../utils/convolution/">Convolution</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../utils/sparse/">Sparse</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../utils/misc/">Miscellaneous</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Other</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../external/">External resources</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../about/">About</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">Spektral</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
        
          <li>Data &raquo;</li>
        
      
    
    <li>Containers</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>

          <div role="main">
            <div class="section">
              
                <h2 id="data">Data</h2>
<p><span style="float:right;"><a href="https://github.com/danielegrattarola/spektral/blob/master/spektral/data/graph.py#L7">[source]</a></span></p>
<h4 id="graph">Graph</h4>
<pre><code class="language-python">spektral.data.graph.Graph(x=None, a=None, e=None, y=None)
</code></pre>
<p>A container to represent a graph. The data associated with the Graph is
stored in its attributes:</p>
<ul>
<li><code>x</code>, for the node features;</li>
<li><code>a</code>, for the adjacency matrix;</li>
<li><code>e</code>, for the edge attributes;</li>
<li><code>y</code>, for the node or graph labels;</li>
</ul>
<p>All of these default to <code>None</code> if you don't specify them in the constructor.
If you want to read all non-None attributes at once, you can call the
<code>numpy()</code> method, which will return all data in a tuple (with the order
defined above).</p>
<p>Graphs also have the following attributes that are computed automatically
from the data:</p>
<ul>
<li><code>n_nodes</code>: number of nodes;</li>
<li><code>n_edges</code>: number of edges;</li>
<li><code>n_node_features</code>: size of the node features, if available;</li>
<li><code>n_edge_features</code>: size of the edge features, if available;</li>
<li><code>n_labels</code>: size of the labels, if available;</li>
</ul>
<p>Any additional <code>kwargs</code> passed to the constructor will be automatically
assigned as instance attributes of the graph.</p>
<p>Data can be stored in Numpy arrays or Scipy sparse matrices, and labels can
also be scalars.</p>
<p>Spektral usually assumes that the different data matrices have specific
shapes, although this is not strictly enforced to allow more flexibility.
In general, node attributes should have shape <code>(n_nodes, n_node_features)</code> and the adjacency
matrix should have shape <code>(n_nodes, n_nodes)</code>.</p>
<p>Edge attributes can be stored in a dense format as arrays of shape
<code>(n_nodes, n_nodes, n_edge_features)</code> or in a sparse format as arrays of shape <code>(n_edges, n_edge_features)</code>
(so that you don't have to store all the zeros for missing edges). Most
components of Spektral will know how to deal with both situations
automatically.</p>
<p>Labels can refer to the entire graph (shape <code>(n_labels, )</code>) or to each
individual node (shape <code>(n_nodes, n_labels)</code>).</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x</code>: np.array, the node features (shape <code>(n_nodes, n_node_features)</code>);</li>
<li><code>a</code>: np.array or scipy.sparse matrix, the adjacency matrix (shape <code>(n_nodes, n_nodes)</code>);</li>
<li><code>e</code>: np.array, the edge features (shape <code>(n_nodes, n_nodes, n_edge_features)</code> or <code>(n_edges, n_edge_features)</code>);</li>
<li><code>y</code>: np.array, the node or graph labels (shape <code>(n_nodes, n_labels)</code> or <code>(n_labels, )</code>);</li>
</ul>
<hr />
<p><span style="float:right;"><a href="https://github.com/danielegrattarola/spektral/blob/master/spektral/data/dataset.py#L13">[source]</a></span></p>
<h4 id="dataset">Dataset</h4>
<pre><code class="language-python">spektral.data.dataset.Dataset(transforms=None)
</code></pre>
<p>A container for Graph objects. This class can be extended to represent a
graph dataset.</p>
<p>To create a <code>Dataset</code>, you must implement the <code>Dataset.read()</code> method, which
must return a list of <code>spektral.data.Graph</code> objects:</p>
<pre><code class="language-py">class MyDataset(Dataset):
    def read(self):
        return [Graph(x=x, adj=adj, y=y) for x, adj, y in some_magic_list]
</code></pre>
<p>The <code>download()</code> method is automatically called if the path returned by
<code>Dataset.path</code> does not exists (default <code>~/spektral/datasets/ClassName/</code>).</p>
<p>In this case, <code>download()</code> will be called before <code>read()</code>.</p>
<p>Datasets should generally behave like Numpy arrays for any operation that
uses simple 1D indexing:</p>
<pre><code class="language-py">&gt;&gt;&gt; dataset[0]
Graph(...)

&gt;&gt;&gt; dataset[[1, 2, 3]]
Dataset(n_graphs=3)

&gt;&gt;&gt; dataset[1:10]
Dataset(n_graphs=9)

&gt;&gt;&gt; np.random.shuffle(dataset)  # shuffle in-place

&gt;&gt;&gt; for graph in dataset[:3]:
&gt;&gt;&gt;     print(graph)
Graph(...)
Graph(...)
Graph(...)
</code></pre>
<p>Datasets have the following properties that are automatically computed:</p>
<ul>
<li><code>n_nodes</code>: the number of nodes in the dataset (always None, except
in single and mixed mode datasets);</li>
<li><code>n_node_features</code>: the size of the node features (assumed to be equal
for all graphs);</li>
<li><code>n_edge_features</code>: the size of the edge features (assumed to be equal
for all graphs);</li>
<li><code>n_labels</code>: the size of the labels (assumed to be equal for all
graphs); this is computed as <code>y.shape[-1]</code>.</li>
</ul>
<p>Any additional <code>kwargs</code> passed to the constructor will be automatically
assigned as instance attributes of the dataset.</p>
<p>Datasets also offer three main manipulation functions to apply callables to
their graphs:</p>
<ul>
<li><code>apply(transform)</code>: replaces each graph with the output of <code>transform(graph)</code>.
See <code>spektral.transforms</code> for some ready-to-use transforms.<br>
Example: <code>apply(spektral.transforms.NormalizeAdj())</code> normalizes the
adjacency matrix of each graph in the dataset.</li>
<li><code>map(transform, reduce=None)</code>: returns a list containing the output
of <code>transform(graph)</code> for each graph. If <code>reduce</code> is a <code>callable</code>, then
returns <code>reduce(output_list)</code>.<br>
Example: <code>map(lambda: g.n_nodes, reduce=np.mean)</code> will return the
average number of nodes in the dataset.</li>
<li><code>filter(function)</code>: removes from the dataset any graph for which
<code>function(graph) is False</code>.<br>
Example: <code>filter(lambda: g.n_nodes &lt; 100)</code> removes from the dataset all
graphs bigger than 100 nodes.</li>
</ul>
<p>Datasets in mixed mode (one adjacency matrix, many instances of node features)
are expected to have a particular structure.
The graphs returned by <code>read()</code> should not have an adjacency matrix,
which should be instead stored as a singleton in the dataset's <code>a</code> attribute.
For example:</p>
<pre><code class="language-py">class MyMixedModeDataset(Dataset):
    def read(self):
        self.a = compute_adjacency_matrix()
        return [Graph(x=x, y=y) for x, y in some_magic_list]
</code></pre>
<p>Have a look at the <code>spektral.datasets</code> module for examples of popular
datasets already implemented.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>transforms</code>: a callable or list of callables that are automatically
applied to the graphs after loading the dataset.</li>
</ul>
<hr />
<h3 id="data-utils">Data utils</h3>
<h4 id="to_disjoint">to_disjoint</h4>
<pre><code class="language-python">spektral.data.utils.to_disjoint(x_list=None, a_list=None, e_list=None)
</code></pre>
<p>Converts lists of node features, adjacency matrices and edge features to
<a href="https://graphneural.network/spektral/data-modes/#disjoint-mode">disjoint mode</a>.</p>
<p>Either the node features or the adjacency matrices must be provided as input.</p>
<p>The i-th element of each list must be associated with the i-th graph.</p>
<p>The method also computes the batch index to retrieve individual graphs
from the disjoint union.</p>
<p>Edge attributes can be represented as:</p>
<ul>
<li>a dense array of shape <code>(n_nodes, n_nodes, n_edge_features)</code>;</li>
<li>a sparse edge list of shape <code>(n_edges, n_edge_features)</code>;</li>
</ul>
<p>and they will always be returned as a stacked edge list.</p>
<p><strong>Arguments</strong>  </p>
<ul>
<li>
<p><code>x_list</code>: a list of np.arrays of shape <code>(n_nodes, n_node_features)</code>
-- note that <code>n_nodes</code> can change between graphs;</p>
</li>
<li>
<p><code>a_list</code>: a list of np.arrays or scipy.sparse matrices of shape
<code>(n_nodes, n_nodes)</code>;</p>
</li>
<li>
<p><code>e_list</code>: a list of np.arrays of shape
<code>(n_nodes, n_nodes, n_edge_features)</code> or <code>(n_edges, n_edge_features)</code>;</p>
</li>
</ul>
<p><strong>Return</strong><br />
 Only if the corresponding list is given as input:</p>
<ul>
<li><code>x</code>: np.array of shape <code>(n_nodes, n_node_features)</code>;</li>
<li><code>a</code>: scipy.sparse matrix of shape <code>(n_nodes, n_nodes)</code>;</li>
<li><code>e</code>: np.array of shape <code>(n_edges, n_edge_features)</code>;</li>
<li><code>i</code>: np.array of shape <code>(n_nodes, )</code>;</li>
</ul>
<hr />
<h4 id="to_batch">to_batch</h4>
<pre><code class="language-python">spektral.data.utils.to_batch(x_list=None, a_list=None, e_list=None, mask=False)
</code></pre>
<p>Converts lists of node features, adjacency matrices and edge features to
<a href="https://graphneural.network/data-modes/#batch-mode">batch mode</a>,
by zero-padding all tensors to have the same node dimension <code>n_max</code>.</p>
<p>Either the node features or the adjacency matrices must be provided as input.</p>
<p>The i-th element of each list must be associated with the i-th graph.</p>
<p>If <code>a_list</code> contains sparse matrices, they will be converted to dense
np.arrays.</p>
<p>The edge attributes of a graph can be represented as</p>
<ul>
<li>a dense array of shape <code>(n_nodes, n_nodes, n_edge_features)</code>;</li>
<li>a sparse edge list of shape <code>(n_edges, n_edge_features)</code>;</li>
</ul>
<p>and they will always be returned as dense arrays.</p>
<p><strong>Arguments</strong>  </p>
<ul>
<li>
<p><code>x_list</code>: a list of np.arrays of shape <code>(n_nodes, n_node_features)</code>
-- note that <code>n_nodes</code> can change between graphs;</p>
</li>
<li>
<p><code>a_list</code>: a list of np.arrays or scipy.sparse matrices of shape
<code>(n_nodes, n_nodes)</code>;</p>
</li>
<li>
<p><code>e_list</code>: a list of np.arrays of shape
<code>(n_nodes, n_nodes, n_edge_features)</code> or <code>(n_edges, n_edge_features)</code>;</p>
</li>
<li>
<p><code>mask</code>: bool, if True, node attributes will be extended with a binary mask that
indicates valid nodes (the last feature of each node will be 1 if the node is valid
and 0 otherwise). Use this flag in conjunction with layers.base.GraphMasking to
start the propagation of masks in a model.</p>
</li>
</ul>
<p><strong>Return</strong><br />
 Only if the corresponding list is given as input:</p>
<ul>
<li><code>x</code>: np.array of shape <code>(batch, n_max, n_node_features)</code>;</li>
<li><code>a</code>: np.array of shape <code>(batch, n_max, n_max)</code>;</li>
<li><code>e</code>: np.array of shape <code>(batch, n_max, n_max, n_edge_features)</code>;</li>
</ul>
<hr />
<h4 id="to_mixed">to_mixed</h4>
<pre><code class="language-python">spektral.data.utils.to_mixed(x_list=None, a=None, e_list=None)
</code></pre>
<p>Converts lists of node features and edge features to
<a href="https://graphneural.network/data-modes/#mixed-mode">mixed mode</a>.</p>
<p>The adjacency matrix must be passed as a singleton, i.e., a single np.array
or scipy.sparse matrix shared by all graphs.</p>
<p>Edge attributes can be represented as:</p>
<ul>
<li>a dense array of shape <code>(n_nodes, n_nodes, n_edge_features)</code>;</li>
<li>a sparse edge list of shape <code>(n_edges, n_edge_features)</code>;</li>
</ul>
<p>and they will always be returned as a batch of edge lists.</p>
<p><strong>Arguments</strong>  </p>
<ul>
<li>
<p><code>x_list</code>: a list of np.arrays of shape <code>(n_nodes, n_node_features)</code>
-- note that <code>n_nodes</code> must be the same between graphs;</p>
</li>
<li>
<p><code>a</code>: a np.array or scipy.sparse matrix of shape <code>(n_nodes, n_nodes)</code>;</p>
</li>
<li>
<p><code>e_list</code>: a list of np.arrays of shape
<code>(n_nodes, n_nodes, n_edge_features)</code> or <code>(n_edges, n_edge_features)</code>;</p>
</li>
</ul>
<p><strong>Return</strong><br />
 Only if the corresponding element is given as input:</p>
<ul>
<li><code>x</code>: np.array of shape <code>(batch, n_nodes, n_node_features)</code>;</li>
<li><code>a</code>: scipy.sparse matrix of shape <code>(n_nodes, n_nodes)</code>;</li>
<li><code>e</code>: np.array of shape <code>(batch, n_edges, n_edge_features)</code>;</li>
</ul>
<hr />
<h4 id="batch_generator">batch_generator</h4>
<pre><code class="language-python">spektral.data.utils.batch_generator(data, batch_size=32, epochs=None, shuffle=True)
</code></pre>
<p>Iterates over the data for the given number of epochs, yielding batches of
size <code>batch_size</code>.</p>
<p><strong>Arguments</strong>  </p>
<ul>
<li>
<p><code>data</code>: np.array or list of np.arrays with the same first dimension;</p>
</li>
<li>
<p><code>batch_size</code>: number of samples in a batch;</p>
</li>
<li>
<p><code>epochs</code>: number of times to iterate over the data (default None, iterates
indefinitely);</p>
</li>
<li>
<p><code>shuffle</code>: whether to shuffle the data at the beginning of each epoch</p>
</li>
</ul>
<p><strong>Return</strong><br />
 Batches of size <code>batch_size</code>.</p>
<hr />
<h4 id="to_tf_signature">to_tf_signature</h4>
<pre><code class="language-python">spektral.data.utils.to_tf_signature(signature)
</code></pre>
<p>Converts a Dataset signature to a TensorFlow signature.</p>
<p><strong>Arguments</strong>  </p>
<ul>
<li><code>signature</code>: a Dataset signature.</li>
</ul>
<p><strong>Return</strong><br />
 A TensorFlow signature.</p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../datasets/" class="btn btn-neutral float-right" title="Datasets">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../models/" class="btn btn-neutral" title="Models"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
        <span>
          <a href="https://github.com/danielegrattarola/spektral/" class="fa fa-github" style="color: #fcfcfc"> GitHub</a>
        </span>
    
    
      <span><a href="../models/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../datasets/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme_extra.js" defer></script>
    <script src="../js/theme.js" defer></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" defer></script>
      <script src="../js/macros.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
